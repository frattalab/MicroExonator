#!/usr/bin/env python3


'''
In the provided workflow there doesn't seem to be a clean way to clasify microexons as annotated or novel
src/stats/discovery_stats.py seems to be on the way there but seems to generate 'gtf-like' output
which doesn't provide a simple link between the microexonator output tables and annotation status
Also seems to only compare BED12 transcript annotation to MicroExonator output

This script will create a additional tables (.tsv) for each Microexonator output table following columns appended:
annotation_status

annotation_status can have following values:
"annotated" - Microexon is found in "data/ME_canonical_SJ_tags.DB.fa" (generated from Gene_anontation_bed12 & ME_DB in config.yaml)
"novel" - Microexon not in provided annotation files and detected by Microexonator in Discovery module (Round1 - passing their 'minimal filters')

To do this make use of the following files:
*from my understanding*

"data/ME_canonical_SJ_tags.DB.fa" - generated by Get_ME_from_annotation in Round2.skm
- FASTA file of all microexons present in provided annotation files (Gene_anontation_bed12 & ME_DB in config.yaml)
> <microexon sequence tag>
<reference sequence>

Assume if microexon's reference tag is not present in "data/ME_canonical_SJ_tags.DB.fa" then microexon is novel
(using canonical.db as much smaller than Round2/.de_novo)

In discovery stats only using ME (first column) from Microexonator output tables to match microexons with microexons from reference
will do same here but also check ME sequence - I like to be cautious...

1. Read Fasta headers from "data/ME_canonical_SJ_tags.DB.fa" into list ('annotated list')
2. For each output table - check if each microexon is in 'annotated list' - assign as "annotated" if True, else "novel"
3. Append new data as column to output table and write to file

Reference names have general format:
    chr17:42981074+42987255|ENST00000361677.5|100_GGCTTG_100
    splice_junction | tr_id | 5' upstream extension _ microexon_seq _ 3' upstream extension

output tables all have splice_junction (4th column) & microexon sequence 7th (mex_sequence)

'''

from Bio import SeqIO
import sys
import csv

def get_me_tags_from_fasta(fasta):
    '''
    Return list of microexon reference sequence tags from header of FASTA file use for ME alignment
    '''

    with open(fasta) as infile:
        me_tags = [sj_tag.id for sj_tag in SeqIO.parse(infile,"fasta")]

    return me_tags

def update_row(row_list,row_number, annot_list, column_name,annot_val,novel_val):
    '''
    Append row_list with one of column_name,annot_val,novel_val depending on conditions
    if row_number == 1 then list corresponds to header - append column_name
    else check if microexon in row_list is found in annot_list
        if True then append annot_val (microexon is annotated)
        if False then append novel_val (microexon not found in annotation)

    Reference names have general format:
        chr17:42981074+42987255|ENST00000361677.5|100_GGCTTG_100
        splice_junction | tr_id | 5' upstream extension _ microexon_seq _ 3' upstream extension

    output tables all have splice_junction (4th column) & microexon sequence 7th (mex_sequence)
    '''
    if row_number == 1:
        row_list.append(column_name) # add to header
        return row_list
        
    else:

        #output tables all have splice_junction (4th column) & microexon sequence 7th (mex_sequence)
        me_sj_coords = row_list[3]
        mex_sequence = row_list[6]

        #me_sj_coords sometimes has multiple SJs separated by commas - if true then check each one
        if ',' in me_sj_coords:
            me_sj_coords_list = me_sj_coords.split(',')

            tracker = None #this pointer is updated if ME is found in annotated list - if not None then have already updated row and don't want to again
            for coords in me_sj_coords_list:
                if tracker is not None:
                    break # stop checking all possible sj coords - has already been found
                else:
                    for reference_tag in annot_list:
                        if coords == reference_tag.split('|')[0] and mex_sequence == reference_tag.split('|')[2].split('_')[1]:
                            #microexon found in annotated list - add to row list and stop checking for match
                            row_list.append(annot_val)
                            tracker = "found"
                            break # stop looking through annot_list to check for matches (breaks for reference_tag in annot_list loop )

            #now have checked every possible SJ & me_seq combo for presence in annotation - if tracker still None then ME not found in reference list
            if tracker is None:
                row_list.append(novel_val)

        else:
            tracker = None #this pointer is updated if ME is found in annotated list - if not None then have already updated row and don't want to again
            for reference_tag in annot_list:
                if me_sj_coords == reference_tag.split('|')[0] and me_sj_coords == reference_tag.split('|')[2].split('_')[1]:
                    #microexon found in annotated list - add to row list and stop checking for match
                    row_list.append(annot_val)
                    tracker = "found"
                    break # stop looking through annot_list to check for matches

            #now have checked microexon for presence in annotation - if tracker still None then ME not found in reference list
            if tracker is None:
                row_list.append(novel_val)

        return row_list



def write_annot_status(table_path, annot_tags_list, colname = "annotation_status", annot_str = "annotated", novel_str = "novel",out_suffix="annot_status"):
    '''
    Takes a Microexonator output table, appends an annotation_status column and writes to file
    rows take annot_str value if found in annot_tags_list, else novel_str value
    '''

    #get outfile name by inserting out_suffix before the file extension
    split_path = table_path.split('.')
    split_path.insert(-1, out_suffix)
    outfile = '.'.join(split_path)

    with open(table_path) as in_table, open(outfile,"w") as out_table:
        table_reader = csv.reader(in_table, delimiter="\t")
        table_writer = csv.writer(out_table, delimiter="\t")

        for row in table_reader:
            updated_row = update_row(row, table_reader.line_num, annot_tags_list, colname, annot_str, novel_str)
            table_writer.writerow(updated_row)

    return


def main(canonical_fasta, me_table_list):

    me_annotated_tags = get_me_tags_from_fasta(canonical_fasta)
    #print(me_annotated_tags)

    for out_table in me_table_list:
        write_annot_status(out_table,me_annotated_tags)

if __name__ == '__main__':
    annotated_fasta = sys.argv[1]
    output_table_list = sys.argv[2].split(',')
    main(annotated_fasta, output_table_list)
